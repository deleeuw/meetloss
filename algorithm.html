<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-05-05">

<title>3&nbsp; Algorithm – Homogeneity Analysis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./mca.html" rel="next">
<link href="./coding.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-de6c7be80aad2e30aa3088f7100c4292.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./algorithm.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Algorithm</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="./index.html" class="sidebar-logo-link">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Homogeneity Analysis</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Coding and Transformations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./algorithm.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Algorithm</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./mca.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Multiple Correspondence Analysis and homals()</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ca.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Correspondence Analysis and corals()</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./pca.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Nonlinear Principal Component Analysis and princals()</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./canals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Canonical Analysis and canals()</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#block-relaxation" id="toc-block-relaxation" class="nav-link active" data-scroll-target="#block-relaxation"><span class="header-section-number">3.1</span> Block Relaxation</a></li>
  <li><a href="#majorization" id="toc-majorization" class="nav-link" data-scroll-target="#majorization"><span class="header-section-number">3.2</span> Majorization</a></li>
  <li><a href="#alternating-least-squares" id="toc-alternating-least-squares" class="nav-link" data-scroll-target="#alternating-least-squares"><span class="header-section-number">3.3</span> Alternating Least Squares</a></li>
  <li><a href="#implementation-details" id="toc-implementation-details" class="nav-link" data-scroll-target="#implementation-details"><span class="header-section-number">3.4</span> Implementation Details</a></li>
  <li><a href="#wrappers" id="toc-wrappers" class="nav-link" data-scroll-target="#wrappers"><span class="header-section-number">3.5</span> Wrappers</a></li>
  <li><a href="#structures" id="toc-structures" class="nav-link" data-scroll-target="#structures"><span class="header-section-number">3.6</span> Structures</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Algorithm</span></h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="block-relaxation" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="block-relaxation"><span class="header-section-number">3.1</span> Block Relaxation</h2>
<p>Our task is to minimize <span class="math inline">\(\sigma(H,A)\)</span> over <span class="math inline">\(H\)</span> and <span class="math inline">\(A\)</span>, suitably constrained. Write the constraints as <span class="math inline">\(H\in\mathcal{H}\)</span> and <span class="math inline">\(A\in\mathcal{A}\)</span>. The strategy we use is block relaxation (<span class="citation" data-cites="deleeuw_B_15">(<a href="#ref-deleeuw_B_15" role="doc-biblioref"><strong>deleeuw_B_15?</strong></a>)</span>). Thus we iterate as follows.</p>
<ol start="0" type="1">
<li>Set <span class="math inline">\(k=0\)</span> and start with some <span class="math inline">\(H^{(0)}\)</span>.</li>
<li><span class="math inline">\(A^{(k)}\in\amin{A\in\mathcal{A}}\ \sigma(H^{(k)},A)\)</span>.</li>
<li><span class="math inline">\(H^{(k+1)}\in\amin{H\in\mathcal{H}}\ \sigma(H,A^{(k)})\)</span>.</li>
<li>If converged stop. Else <span class="math inline">\(k\leftarrow k+1\)</span> and go to step 1.</li>
</ol>
<p>It is assumed that step 1, updating <span class="math inline">\(A\)</span> for given <span class="math inline">\(H\)</span>, can be carried out simply by some form of linear least squares. We assume that for each <span class="math inline">\(\ell\)</span> there is at least one <span class="math inline">\(j\)</span> such that <span class="math inline">\(A_{j\ell}=I\)</span>. Note that this is the case for MLR, PCA, EFA, and for all Gifi Systems.</p>
<p>Step 2 is somewhat more intricate, because of the cone restrictions. In partitioned form we can write the loss function as <span class="math display">\[
\sigma(H,A)=\sum_{i=1}^m\mathbf{tr}\ H_i'\sum_{j=1}^mH_j\sum_{\ell=1}^LA_{j\ell}A_{i\ell}'
\]</span></p>
<p><span class="math display">\[
B_{ij}(A)=\sum_{\ell=1}^LA_{j\ell}A_{i\ell}'
\]</span></p>
</section>
<section id="majorization" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="majorization"><span class="header-section-number">3.2</span> Majorization</h2>
<p><span class="math display">\[
\mathbf{tr}\ H'HG=\mathbf{tr}\ (\tilde H + (H - \tilde H))'(\tilde H + (H - \tilde H))G\geq\\\mathbf{tr}\ \tilde H'\tilde HG+2\mathbf{tr}\ \tilde H'(H - \tilde H)G
\]</span></p>
<p><span class="math display">\[
\mathbf{tr}\ H'\tilde HG(\tilde H)
\]</span></p>
</section>
<section id="alternating-least-squares" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="alternating-least-squares"><span class="header-section-number">3.3</span> Alternating Least Squares</h2>
<p>The standard way to minimize loss function <span class="math inline">\(\eqref{E:oldloss}\)</span> is implemented in the <code>OVERALS</code> program <span class="citation" data-cites="vanderburg_deleeuw_verdegaal_A_88">Meulman and Heiser (<a href="#ref-meulman_heiser_12" role="doc-biblioref">2012</a>)</span>. It is also the one used in the <code>homals</code> package <span class="citation" data-cites="deleeuw_mair_A_09a">(<a href="#ref-deleeuw_mair_A_09a" role="doc-biblioref">De Leeuw and Mair 2009</a>)</span>.</p>
<p>In this paper the algorithm is different because we use the loss function <span class="math inline">\(\eqref{E:gifiloss}\)</span>. We still use ALS, which means in this case that we cycle through three substeps in each iteration. We update <span class="math inline">\(A\)</span> for given <span class="math inline">\(X\)</span> and <span class="math inline">\(H\)</span>, we then update <span class="math inline">\(X\)</span> for given <span class="math inline">\(H\)</span> and <span class="math inline">\(A\)</span>, and finally we update <span class="math inline">\(H\)</span> for given <span class="math inline">\(X\)</span> and <span class="math inline">\(A\)</span>. Algorithm A goes as follows.</p>
<ol start="0" type="1">
<li>Set <span class="math inline">\(k=0\)</span> and start with some <span class="math inline">\(X^{(0)},H^{(0)},A^{(0)}\)</span>.</li>
<li><span class="math inline">\(X^{(k+1)}=\mathbf{ortho}(\mathbf{center}(H^{(k)}A^{(k)})\)</span>.</li>
<li>For <span class="math inline">\(j=1,\cdots,m\)</span> compute <span class="math inline">\(A_j^{(k+1)}=\{H_j^{(k)}\}^+X^{(k+1)}\)</span>.</li>
<li>For <span class="math inline">\(j=1,\cdots,m\)</span> and <span class="math inline">\(s=1,\cdots p_j\)</span> compute <span class="math inline">\(h_{js}^{(k+1)}=\mathbf{proj}_{\mathcal{K}_{js}\cap\mathcal{S}}((X^{(k+1)}-\sum_{t&lt;s}h_{jt}^{(k+1)}\{a_{jt}^{(k+1)}\}'-\sum_{t&gt;s}h_{jt}^{(k)}\{a_{jt}^{(k+1)}\}')a_s^{(k+1)})\)</span>.</li>
<li>If converged stop. Else <span class="math inline">\(k\leftarrow k+1\)</span> and go to step 1.</li>
</ol>
<p>In step 1 we use superscript + for the Moore-Penrose inverse. In step 2 the center operator does column centering, the ortho operator finds an orthonormal basis for the column space of its argument.</p>
<p>The complicated part is step 4, the <em>optimal scaling</em>, i.e.&nbsp;the updating of <span class="math inline">\(H_j\)</span> for given <span class="math inline">\(X\)</span> and <span class="math inline">\(A_j\)</span>. We cycle through the variables in the block, each time projecting a single column on the cone of admissible transformations of the variable, and then normalizing the projection to length one. The <em>target</em>, i.e.&nbsp;the vector we are projecting, is complicated, because the other variables in the same block must be taken into account.</p>
<p>In order to simplify the optimal scaling computations within an iteration we can use majorization <span class="citation" data-cites="deleeuw_C_94c">(<a href="#ref-deleeuw_B_15" role="doc-biblioref"><strong>deleeuw_B_15?</strong></a>)</span>. This has the additional benefit that the optimal scaling step becomes embarassingly parallel. We expand the loss for block <span class="math inline">\(j\)</span> around a previous solution <span class="math inline">\(\tilde H_j\)</span>. <span class="math display">\[
\mathbf{SSQ}(X-H_jA_j)=
\mathbf{SSQ}(X-\tilde H_jA_j)-2\mathbf{tr}\ (H_j-\tilde H_j)'(X-\tilde H_jA_j)A_j'
+\mathbf{tr}\ A_j'(H_j-\tilde H_j)'(H_j-\tilde H_j)A_j.
\]</span> Now <span class="math display">\[
\mathbf{tr}\ (H_j-\tilde H_j)A_jA_j'(H_j-\tilde H_j)'\leq\kappa_j\ \mathbf{tr}\ (H_j-\tilde H_j)'(H_j-\tilde H_j),
\]</span> where <span class="math inline">\(\kappa_j\)</span> is the largest eigenvalue of <span class="math inline">\(A_j'A_j\)</span>. Thus <span class="math display">\[
\mathbf{SSQ}(X-H_jA_j)\leq\mathbf{SSQ}(X-\tilde H_jA_j)+\kappa_j\ \mathbf{SSQ}(H_j-U_j)-\frac{1}{\kappa_j}\ \mathbf{SSQ}((X-\tilde H_jA_j)A_j'),
\]</span> where <span class="math inline">\(U_j\)</span> is the <em>target</em> <span class="math display">\[
U_j=\tilde H_j+\frac{1}{\kappa_j}(X-\tilde H_jA_j)A_j'.\tag{3}
\]</span> It follows we can update the optimal scaling of the variables by projecting the columns of <span class="math inline">\(U_j\)</span> on their respective cones and then normalizing. See <span class="citation" data-cites="deleeuw_U_75a">De Leeuw (<a href="#ref-deleeuw_U_75a" role="doc-biblioref">1975</a>)</span> for results on normalized cone regression. This can be done for all variables in the block separately, without taking any of the other variables in the block (or in any of the other blocks) into account. Thus the optimal scaling is easy to parallellize. The resulting algorithm B is as follows.</p>
<ol start="0" type="1">
<li>Set <span class="math inline">\(k=0\)</span> and start with some <span class="math inline">\(X^{(0)},H^{(0)},A^{(0)}\)</span>.</li>
<li><span class="math inline">\(X^{(k+1)}=\mathbf{ortho}(\mathbf{center}(H^{(k)}A^{(k)})\)</span>.</li>
<li>For <span class="math inline">\(j=1,\cdots,m\)</span> compute <span class="math inline">\(A_j^{(k+1)}=\{H_j^{(k)}\}^+X^{(k+1)}\)</span>.</li>
<li>For <span class="math inline">\(j=1,\cdots,m\)</span> compute <span class="math inline">\(U_j^{(k+1)}=H_j^{(k)}+\frac{1}{\kappa_j}(X^{(k+1)}-H_j^{(k)}A_j^{(k+1)})\{A_j^{(k+1)}\}'\)</span> and for <span class="math inline">\(s=1,\cdots p_j\)</span> compute <span class="math inline">\(h_{js}^{(k+1)}=\mathbf{proj}_{\mathcal{K}_{js}\cap\mathcal{S}}(u_{js}^{(k+1)})\)</span>.</li>
<li>If converged stop. Else <span class="math inline">\(k\leftarrow k+1\)</span> and go to step 1.</li>
</ol>
</section>
<section id="implementation-details" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="implementation-details"><span class="header-section-number">3.4</span> Implementation Details</h2>
<p>If we follow the ALS strategy strictly the <span class="math inline">\(\mathbf{ortho}()\)</span> operator should be implemented using Procrustus rotation <span class="citation" data-cites="gibson_62">(<a href="#ref-gibson_62" role="doc-biblioref">Gibson 1962</a>)</span>. Thus if <span class="math inline">\(Z=K\Lambda L'\)</span> is the singular value decomposition of <span class="math inline">\(X\)</span>, then <span class="math inline">\(\mathbf{ortho}(Z)=KL'\)</span>. Note, however, that any other basis for the column space of <span class="math inline">\(Z\)</span> merely differs from the Procrustus basis by a rotation. And this rotation matrix will carry unmodified into the upgrade of <span class="math inline">\(A_j\)</span> in step 2 of the algorithm, and thus after steps 1 and 2 the loss will be the same, no matter which rotation we select. In our algorithm we use the QR decomposition to find the basis, using the Gram-Schmidt code from <span class="citation" data-cites="deleeuw_E_15d">De Leeuw (<a href="#ref-deleeuw_E_15d" role="doc-biblioref">2015a</a>)</span>.</p>
<p>In actual computation we column-center the basis and compute a full rank QR decomposition, using the code in <span class="citation" data-cites="deleeuw_E_15d">De Leeuw (<a href="#ref-deleeuw_E_15d" role="doc-biblioref">2015a</a>)</span>. Thus <span class="math inline">\(G_\ell=Q_\ell R_\ell\)</span>,</p>
<p>We implement the cone restrictions by the constraints <span class="math inline">\(h_{js}=G_{js}z_s\)</span> in combination with <span class="math inline">\(T_{js}h_{js}\geq 0\)</span>. Thus the transformed variables must be in the intersection of the subspace spanned by the columns of the <em>transformation basis</em> <span class="math inline">\(G_{js}\)</span> and the polyhedral convex cones of all vectors <span class="math inline">\(h\)</span> such that <span class="math inline">\(T_{js}h\geq 0\)</span>. We suppose that all columns of the <span class="math inline">\(G_{js}\)</span> add up to zero, and we require, in addition, the normalization <span class="math inline">\(SSQ(h_{js})=1\)</span>.</p>
<p>We use the code described in <span class="citation" data-cites="deleeuw_E_15e">De Leeuw (<a href="#ref-deleeuw_E_15e" role="doc-biblioref">2015b</a>)</span> to generate B-spline bases. Note that for coding purposes binary indicators are B-splines of degree zero, while polynomials are B-splines without interior knots. We include the utility functions to generate lists of knots. There is <code>knotsQ()</code> for knots at the quantiles, <code>knotsR()</code> for knots equally spaced on the range, <code>knotsD()</code> for knots at the data points, and <code>knotsE()</code> for no interior knots. Also note that binary indicators can be created for qualitative non-numerical variables, for which B-splines are not defined. We have added the option using degree -1 to bypass the B-spline code and generate an indicator matrix, using the utility <code>makeIndicator()</code>. Note that <code>'makeIndicator(foo)</code> is equivalent to <code>bsplineBasis(foo, degree = 0, innerknots = sort(unique(foo)))</code>. Throughout we first orthonormalize the basis matrices <span class="math inline">\(G_{js}\)</span>, using the Gram-Schmidt code from <span class="citation" data-cites="deleeuw_E_15d">De Leeuw (<a href="#ref-deleeuw_E_15d" role="doc-biblioref">2015a</a>)</span>.</p>
<p>The matrices <span class="math inline">\(T_{js}\)</span> in the homogeneous linear inequality restrictions that define the cones <span class="math inline">\(\mathcal{K}_{js}\)</span> can be used to define monotonicity or convexity of the resulting transformations. In the current implementation we merely allow for monotonicity, which means the <span class="math inline">\(T_{js}\)</span> do not have to be stored. The transformations for each variable can be restricted to be increasing, or they can be unrestricted. By using splines without interior knots we allow in addition for polynomial transformations, which again can be restricted to be either monotonic or not. Note that it is somewhat misleading to say we are fitting monotone splines or polynomials, we are mainly requiring monotonicity at the data points.</p>
<p>If there are multiple copies of a variable in a block then requiring the transformation to be ordinal means that we want the transformation of the first copy to be monotonic. The transformations of the other copies are not constrained to be monotonic. If you want all copies to be transformed monotonically, you have to explicitly introduce them as separate variables.</p>
<p>For variables with copies there is yet another complication. For copies we have <span class="math inline">\(H_jA_j=G_j(Z_jA_j)=G_jY_j\)</span>. If we require monotonicity in MVAOS we constrain a column of <span class="math inline">\(H_j\)</span> (in fact, the first one) to be monotonic. In classic Gifi, in which the <span class="math inline">\(G_j\)</span> are binary indicators, we constrain the first column of <span class="math inline">\(Y_j\)</span>, which automatically implies the first column of <span class="math inline">\(G_jY_j\)</span> is monotonic as well. In previous Gifi work with B-splines, we also constrained the first column of <span class="math inline">\(Y_j\)</span>, which again implied the first column of <span class="math inline">\(G_jY_j\)</span> was monotnic as well. But in our current MVAOS implementation monotonicity of the first column of <span class="math inline">\(H_j\)</span> does not imply monotonicity of the first column of <span class="math inline">\(H_jA_j\)</span>, even if the basis <span class="math inline">\(G_j\)</span> is a binary indicator. This discrepancy between the old and the new Gifi only comes into play for ordinal variables with multiple copies.</p>
<p>Missing data are incorporated in the definition of the cones of transformations by using a <span class="math inline">\(G_{js}\)</span> which is the direct sum of a spline basis for the non-missing and an identity matrix for the missing data. This is called <em>missing data multiple</em> in <span class="citation" data-cites="gifi_B_90">Gifi (<a href="#ref-gifi_B_90" role="doc-biblioref">1990</a>)</span>. There are no linear inequality restrictions on the quantifications of the missing data.</p>
</section>
<section id="wrappers" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="wrappers"><span class="header-section-number">3.5</span> Wrappers</h2>
<p>The <code>homals()</code> implementation in <span class="citation" data-cites="deleeuw_mair_A_09a">De Leeuw and Mair (<a href="#ref-deleeuw_mair_A_09a" role="doc-biblioref">2009</a>)</span> is a single monolithic program in R, which specializes to the various MVAOS techniques by a suitable choice of its parameters. This approach has some disadvantages. If we want principal component analysis, we already know all blocks are singletons. If we want multiple correspondence analysis we know each variable has <span class="math inline">\(p\)</span> copies. If we want multiple regression, we know there are two blocks, and one is a singleton. So it is somewhat tedious to specify all parameters all of the time. Also, some of the output, graphical and otherwise, is specific to a particular technique. For regression we want residuals and fitted values, in canonical analysis we want block scores and loadings. And, more generally, we may want the output in a form familiar from the classical MVA techniques. It is indeed possible to transform the <code>homals()</code> output to more familar forms (<span class="citation" data-cites="deleeuw_R_09c">De Leeuw (<a href="#ref-deleeuw_R_09c" role="doc-biblioref">2009</a>)</span>), but this requires some extra effort.</p>
<p>In this book we go back to the original approach of <span class="citation" data-cites="gifi_B_90">Gifi (<a href="#ref-gifi_B_90" role="doc-biblioref">1990</a>)</span> and write separate programs for nonlinear versions principal component analysis, multiple regression, canonical analysis, discriminant analysis, and so on.</p>
<p>These programs, now written in R and no longer in FORTRAN, are wrappers for the main computational core, the program <code>gifiEngine()</code>. The wrappers, which have the familiar names <code>morals()</code>, <code>corals()</code>, <code>princals()</code>, <code>homals()</code>, <code>criminals()</code>, <code>overals()</code>, <code>primals()</code>, and <code>canals()</code>, create a gifi object from the data and parameters, and then pass this to <code>gifiEngine()</code>. Computations are itereated to convergence, and result are stored in a xGifi object. Then the output is transformed to a format familiar from the corresponding technique from classical MVA. Each wrapper <code>foo</code> returns a structure of class <code>foo</code>.</p>
<p>This modular approach saves code, because both <code>makeGifi()</code> and <code>gifiEngine()</code> are common to all programs. It also makes it comparatively easy to add new wrappers not currently included, possibly even contributed by others.</p>
<p>Although we like the above quotation from <span class="citation" data-cites="hill_90">Hill (<a href="#ref-hill_90" role="doc-biblioref">1990</a>)</span>, it is not quite accurate. Our current generation of wrappers can use B-spline bases, it can use an arbitrary number of copies of a variable, and each copy can be either categorical, ordinal, polynomial, or splinical. Thus, even more so than the original gifi programs, we have a substantial generalization of the classical techniques, not merely a sequence of synonyms.</p>
</section>
<section id="structures" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="structures"><span class="header-section-number">3.6</span> Structures</h2>
<p>The computations are controlled by the arguments to the wrappers. These arguments are used to construct three structures: the gifi, the gifiBlock, and the gifiVariable. A gifi is just a list of gifiBlocks, and a gifiBlock is a list of gifiVariables. This reflects the partitioning of the variables into blocks. A gifiVariable contains a great deal of information about the variable. The function <code>makeGifiVariable()</code> is a constructor that returns a structure of class <code>gifiVariable</code>. The contents of a <code>gifiVariable</code> remain the same throughout the computations.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="fu">structure</span> (</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="fu">list</span> (</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="at">data =</span> data,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="at">basis =</span> basis,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="at">qr =</span> qr,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="at">copies =</span> copies,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="at">degree =</span> degree,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="at">ties =</span> ties,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="at">missing =</span> missing,</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="at">ordinal =</span> ordinal,</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="at">active =</span> active,</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="at">name =</span> name,</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="at">type =</span> type</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      ),</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">class =</span> <span class="st">"gifiVariable"</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    ))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>There are three corresponding structures containing initial and intermediate results, and eventually output, the xGifi, xGifiBlock, and xGifiVariable. Again, an xGifi is a list of xGifiBlocks, and an xGifiBlock is a list of xGifiVariables. The constructor for an xGifiVariable returns an object of class <code>xGifiVariable</code>, which contains the elements that are updated in each iteration during the computations. There is an <code>xGifiVariable</code> for both active and passive variables.</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a> <span class="fu">return</span> (<span class="fu">structure</span> (</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">list</span>(</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="at">transform =</span> transform,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      <span class="at">weights =</span> weights,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      <span class="at">scores =</span> scores,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>      <span class="at">quantifications =</span> quantifications</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">class =</span> <span class="st">"xGifiVariable"</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  ))</span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-vanderburg_deleeuw_verdegaal_A_88" class="csl-entry" role="listitem">
Burg, E. Van der, J. De Leeuw, and R. Verdegaal. 1988. <span>“Homogeneity Analysis with <span>K</span> Sets of Variables: An Alternating Least Squares Approach with Optimal Scaling Features.”</span> <em>Psychometrika</em> 53: 177–97.
</div>
<div id="ref-deleeuw_U_75a" class="csl-entry" role="listitem">
De Leeuw, J. 1975. <span>“<span class="nocase">A Normalized Cone Regression Approach to Alternating Least Squares Algorithms</span>.”</span> Department of Data Theory FSW/RUL. <a href="https://jansweb.netlify.app/publication/deleeuw-u-75-a/deleeuw-u-75-a.pdf">https://jansweb.netlify.app/publication/deleeuw-u-75-a/deleeuw-u-75-a.pdf</a>.
</div>
<div id="ref-deleeuw_C_94c" class="csl-entry" role="listitem">
———. 1994. <span>“<span class="nocase">Block Relaxation Algorithms in Statistics</span>.”</span> In <em>Information Systems and Data Analysis</em>, edited by H. H. Bock, W. Lenski, and M. M. Richter, 308–24. Berlin: Springer Verlag. <a href="https://jansweb.netlify.app/publication/deleeuw-c-94-c/deleeuw-c-94-c.pdf">https://jansweb.netlify.app/publication/deleeuw-c-94-c/deleeuw-c-94-c.pdf</a>.
</div>
<div id="ref-deleeuw_R_09c" class="csl-entry" role="listitem">
———. 2009. <span>“<span class="nocase">Regression, Discriminant Analysis, and Canonical Analysis with homals</span>.”</span> Preprint Series 562. Los Angeles, CA: UCLA Department of Statistics.
</div>
<div id="ref-deleeuw_E_15d" class="csl-entry" role="listitem">
———. 2015a. <span>“Exceedingly Simple b-Spline Code.”</span>
</div>
<div id="ref-deleeuw_E_15e" class="csl-entry" role="listitem">
———. 2015b. <span>“Regression with Linear Inequality Restrictions on Predicted Values.”</span>
</div>
<div id="ref-deleeuw_mair_A_09a" class="csl-entry" role="listitem">
De Leeuw, J., and P. Mair. 2009. <span>“<span class="nocase">Homogeneity Analysis in <span>R</span>: the Package homals</span>.”</span> <em>Journal of Statistical Software</em> 31 (4): 1–21. <a href="https://www.jstatsoft.org/v31/i04/">https://www.jstatsoft.org/v31/i04/</a>.
</div>
<div id="ref-gibson_62" class="csl-entry" role="listitem">
Gibson, W. A. 1962. <span>“<span class="nocase">On the Least Squares Orthogonalization of an Oblique Transformation</span>.”</span> <em>Psychometrika</em> 27: 193–95.
</div>
<div id="ref-gifi_B_90" class="csl-entry" role="listitem">
Gifi, A. 1990. <em>Nonlinear Multivariate Analysis</em>. New York, N.Y.: Wiley.
</div>
<div id="ref-heiser_95" class="csl-entry" role="listitem">
Heiser, W. J. 1995. <span>“<span class="nocase">Convergent Computing by Iterative Majorization: Theory and Applications in Multidimensional Data Analysis</span>.”</span> In <em>Recent Advantages in Descriptive Multivariate Analysis</em>, edited by W. J. Krzanowski, 157–89. Oxford: Clarendon Press.
</div>
<div id="ref-hill_90" class="csl-entry" role="listitem">
Hill, M. O. 1990. <span>“<span class="nocase">Review of A. Gifi, Multivariate Analysis</span>.”</span> <em>Journal of Ecology</em> 78 (4): 1148–49.
</div>
<div id="ref-lange_hunter_yang_00" class="csl-entry" role="listitem">
Lange, K., D. R. Hunter, and I. Yang. 2000. <span>“<span>Optimization Transfer Using Surrogate Objective Functions</span>.”</span> <em>Journal of Computational and Graphical Statistics</em> 9: 1–20.
</div>
<div id="ref-meulman_heiser_12" class="csl-entry" role="listitem">
Meulman, J. J., and W. J. Heiser. 2012. <em>IBM SPSS Categories 21</em>. IBM Corporation.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./coding.html" class="pagination-link" aria-label="Coding and Transformations">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Coding and Transformations</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./mca.html" class="pagination-link" aria-label="Multiple Correspondence Analysis and homals()">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Multiple Correspondence Analysis and homals()</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>